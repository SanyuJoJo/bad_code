空格     将代码转化为(前面加地址的)汇编代码[==>转化回来（仅汇编代码）]  ||  option==>line prefixes(graph)
自动注释   option==>Auto comments
手动注释
字符交叉引用 Ctrl + X

# 界面
## 初始界面
### IDA View-A

空格     将代码转化为(前面加地址的)汇编代码[==>转化回来（仅汇编代码）]  ||  option==>line prefixes(graph)
自动注释   option==>Auto comments
手动注释
字符交叉引用 Ctrl + X

### Hex view-1
以16进制显示代码

## structure
结构体分析
（作用---?）
### Enms
枚举
枚举一些敏感的端
## imports
导入段
## exports
导出段

### string操作(Strings window)
view==>opensubview==>strings

显示 unicode ASCII 

### 返回上一步界面
<=左箭头 =>右箭头相反
## 转化成伪代码
F5
加壳或者正在加载 按F5没作用
进度条下方没有小三角，即加载完成
### 手动注释
伪代码界面 右键Edit comments

在 IDA View A中
(地址+汇编代码界面)(空格)
G：跳转地址
### 交叉引用图模式
view->graph->xref
可以看到函数及其引用关系图
显示函数的引用关系(调用关系)
## 查看谁调用了该函数
选中某地址=》Ctrl+x，ok即可跳转调用
类比变量，字符串...
## 参数重命名
右键=>Use  standard symbolic constant
### 修改函数名称
左侧函数列表，搜索该函数，右键=>单击Editfunction



像InternetopenUrlA,以类似UrlA结尾，一般为函数接口
InternetopenUrlA--->查百度

## 样本
吾爱破解病毒区
tria.ge
any.run
cnblogs.com
# 插件编写
## idc插件
``` python
ea = ScreenEA()
for i in range(0x00,0x50):
	b=Byte(ea+i)
	decode_byte = b^0x55
	PatchByte(ea+i,decode_byte)
```

``` c++
#include<idc.idc>
static main(){
	auto ea = ScreenEA(),i,b,decode_byte;
	for(i=0x00;i<0x50;i++)
	{
		b=Byte(ea+i)
		decode_byte = b^0x50;
		PatchByte(ea+i,decode_byte);
	}
}
```

``` c++
#include<idc.idc>

static list_callers(bad_func){
	auto func,addr,xref,source;
	//LockByName-->通过函数名称找到函数的地址
	func = LockByName(bad_func);
	//BADADDR-->坏地址（找本程序地址可用）
	if (func == BADADDR){
		Warning("not found:%s",bad_func);
	}
	else {
		//RfirstB找该函数的交叉引用的列表，返回第一个行
		
		for(addr = RfirstB(func);addr!=BADADDR;addr=RnextB(func,addr))
		{
		//实例化交叉引用
		xref = XrefType();
		//fl_CN:远调用 fl_CF:近调用 fl_JF:远跳转 fl_JN:近跳转 ida中显示p为调用
		if (xrel == fl_CN || xref == fl_CF)
		{
			source = GetFunctionName(addr);
			Message("%s is called from 0x%x in %s\n",bad_func,addr,source);
		}
		}
	}
}

static main(){
	list_callers("");
}
```

使用
IDA 
文件--->Script-->选择idc文件


