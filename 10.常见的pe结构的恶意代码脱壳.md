1.收集到的信息 
先找样本：
影响出发
去找痕迹从痕迹找样本

对样本做基本处理：
放在你认为安全的地方
压缩并且设置密码
多几个备份

对样本做分析：

最后就是报告：

处理：
1.关闭
2.过滤
3.修复

2.还是对样本的分析流程有点不熟悉
1.结构
2.静态
3.动态
4.行为

rootkit
狭义定义：Linux环境下带有权限维持功能的恶意代码
广义：带有权限维持功能的恶意代码
服务和计划任务的识别
system.deamon lib库被注入了

Windows下能直接适应环境启动的东西都是pe结构
exe.dll
特点是：都是可以直接单独拿出来分析

# 脱壳
1.脱壳的宏观过程：
1-1越过壳代码
修改程序的入口点，
pe结构下找到ep
写上我们的壳代码
最后跳回到原来的ep（oep）

现在打开一个加过可的程序：
**第一眼看到的是壳代码的ep
壳代码之后才到原来的oep下**
运行原来的程序

脱壳：把上面加粗的那两步跳过
普通的商业壳：
都会有一个操作
pushed
push eax，ebx，ecx，edx，esi，esp，edi
堆栈保护
popad
jmp oep

向上循环直接跳过
一直去找和功能相关的东西

断点
int3： 不管什么情况只要程序的eip走到这里 必断
硬件访问：如果存在某个东西访问了这个地方，那么就自动找到这个地方下断点
写入：如果某个地方只访问不写入，那么就自动找到这个地方下断点
如果我现在想在某个地方执行执行到这里，就自动找到这个地方下断点  



``` asm
mov eax，es[esp+40h]
mov dword ptr [0x00001] ,eax
```

执行：不写总要**用**，用就是访问 

下完硬件访问断点之后运行到断点处
然后找到大的跳转
跳转完了就是源程序

压缩壳和跳转oep壳的难点：
pushad 可以自己手写
push eax
push ebx

所有有难度的壳的特征：
sdk
可以支持你的源代码的编写过程中去加壳
1.壳代码会有权限去模仿你的源代码
2.你的源代码可以分开一些模块来加壳

实战中的脱壳：
通过我们之前的pe查看工具(exeinfope lordpe peid)去查询到壳代码的具体版本，去找到对应的解壳工具

加密的壳：
脱壳之未知加密壳:https://bbs.kanxue.com/thread-270970.html
了解加密的内容
加密具体的代码
api函数的取值过程

github.com/rapid7/metasplioit-framework

od插件(脚本的保留字)：
https://blog.csdn.net/whatday/article/details/8553391
https://bbs.pediy.com/thread-270970.html

IAT表修复（作业）