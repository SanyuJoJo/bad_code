## 2.寄存器
### 通用寄存器
EAX
EBX
ECX
EDX
E表示32位
R表示64位
没有表示16位

### 指向栈底指针
EBP
只有32位和16位

### 指向栈顶指针
ESP
只有32位和16位

### 指向下一步指针
EIP
只有32位和16位

### 指向字符串指针
ESI
只有32位和16位

栈的移动方向+ 向下
					 -  向上
### 当前正在的位置（运行代码的位置）


## 3.内存位置
表现形式
MOV EAX,DWORD PTR DS:[0x03567783] (立即数表现形式)


MOV EBX,0x03567783
MOV EAX,DWORD PTR DS:[EBX] (寄存器表现形式 )

MOV EBX,0x03567783
MOV EAX,DWORD PTR DS:[EBX+4] (偏移量表现形式1)

MOV EAX,0x03567783
MOV EBX,0x2
MOV ECX,DWORD PTR DS:[EAX+EBX*4] ( 偏移量表现形式1)

## 4.运算符
### 加

add eax,ebx
adc eax,ebx
结果都在第一个
add 无符号
adc 有符号

### 减

sub eax,ebx
sbb eax,ebx
同上

### 乘
mul ebx
imul ebx

只有一个参数 乘的是eax
``` asm
mov eax,2;
mov ebx,3;
mul ebx;
mov eax,eax;
```
乘法乘的都是eax，
mul ebx 即ebx乘eax，最后结果存放在eax

### 除

```asm
mov eax,6h
mov ebx,3h

cdq
idiv ebx
push eax
push ebx
```

eax 为被除数
cdq暂时将寄存器位数扩充 32-->64位

## 逻辑运算

逻辑运算是按位

### and
and eax,ebx

结果在eax

### or

or eax,ebx
同上

### xor
xor eax,ebx
同上

not
not eax
同上

## 6.堆栈操作
### push

push eax
将eax的值压栈

### pop

pop ebx
取出的值赋给ebx

## 7.数据移动
### mov
mov eax,ebx
ebx的数据传入eax

### lea
lea eax,地址
只能将地址赋给eax
mov ebx,TESTT
同lea eax 
### xchg
xchg eax,ebx
互相交换位置

## 8.比较
### cmp
cmp eax,ebx

eax-ebx
通过减法的方式进行比较
### test
test eax,ebx
标识符 ds为0 也就是不相等是相同
与运算但不存结果

## 9.跳转
### jmp
jmp  地址
无条件跳转

### j(n)e
等于(不等于)跳转
### j(n)z
等于(不等于)0跳转
``` asm
mov eax,5
cmp eax,6
jz dizhi
```


### j(n)a
大于(不大于)跳转
### j(n)b
小于不小于跳转

## 10.字符串

### movs
movs dword ptr es:[esi],dword ptr ds:[edi]

### stos

stos 地址
将地址作为内存存在目标

修改指定地址里面的内容
## 11.函数
### call

使用函数
call  函数名字(写汇编的时候是这么写的)
call 地址 (反汇编的时候这么写的)
当我们在call函数的时候如果有参数就要push 参数进去

如果不使用call那么堆栈里面的调用就要自己写
主要是函数的参数一定要知道是存在堆栈里面 并且参数的顺序是从后到前（反着来的（1,2）先压2，再压1）
esp-4
jmp
esp+4
jmp

### ret
ret （写汇编的时候是ret）

retn (反汇编的时候是retn)
``` c
int aaa(){
int a=1;
return a;
}

void main(){

__asm{

movs dword ptr es:[esi] , dword ptr ds:[edi]

call aaa
// 函数返回值在ebp里面
mov eax,es:[ebp]
}
}
```
经过试验，函数返回值在eax里（栈顶）