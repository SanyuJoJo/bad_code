1.执行策略

```
Get-ExecutionPolicy
```

```
Set-ExecutionPolicy
```

2.powershell编辑器
![[image-2023070907.png]]


基本语法：
对缩进不敏感
没有强制的分号
以{}作为代码块
保留字和命令必须是大小写区分的




## 1.变量

$a=1
clear-variable 删除变量
GetType(a)      获得变量类型
$global:a=1 全局变量
$script:a=1 脚本变量

```
| 编号 | 变量     | 描述                 |
|:-------|:------- |:----------------|
|1| $$|此变量用于表示会话接收到的最后一行中的最后一个令牌。|
|2 | $? | 此变量用于表示最后一个操作的执行状态。如果没有错误，则返回True，否则返回False。|
|  3 | $^ |此变量用于表示会话接收到的最后一行中的第一个令牌。|
|  4 |$_ |此变量充当$PSItem，它在管道对象中包含当前对象。 |
|  5 | $args| 此变量包含未声明参数的值的数组，这些值传递给脚本，函数或脚本块。|
|  6 | $ConsoleFileName|此变量用于表示控制台文件的路径，该文件最近在会话中使用。|
|  7 |$Error| 此变量用于包含代表最新错误的错误对象数组。|
|  8 | $Event| 此变量用于包含PSEventArgs的对象。PSEventArgs是用于表示正在处理的事件的对象。|
|  9 | $EventSubscriber| 此变量用于包含PSEventSubscriber的对象。该对象包含正在处理的事件的事件订阅者。 |
| 10 | $EventArgs  | 此变量用于包含一个对象，该对象表示第一个事件的参数。 |
| 11 | $false     | 此变量用于表示False。   |
| 12 | $foreach  | 此变量用于包含ForEach循环的枚举数。该变量仅在执行ForEach循环时存在。并在循环完成后删除。 |
| 13 | $Home  | 此变量用于表示用户主目录的完整路径  |
| 14 | $input | 此变量包含一个枚举器，该枚举器枚举传递给该函数的所有输入。它仅适用于脚本块和功能。 |
| 15 | $Host     | 此变量包含一个对象，该对象显示Windows PowerShell的当前主机应用程序。       |
| 16 |$IsLinux   |如果当前会话在Linux操作系统上运行，则此变量值为$True，否则为$False。 |
| 17 |$IsWindows   | 如果当前会话在Windows操作系统上运行，则此变量值为$True，否则为$False。                             |
| 18 |$IsMacOS  | 如果当前会话在MacOS操作系统上运行，则此变量值为$True，否则为$False。  |
| 19 | $null | 此变量用于表示null值或空值。可以使用它来表示脚本和命令中缺少或未定义的值。 |
| 20 | $PID |此变量显示进程的PID，该进程正在托管当前PowerShell的会话。|
| 21 | $PSItem| 此变量充当$_，它在管道对象中包含当前对象。|
| 22 | $PSHome| 此变量表示Windows PowerShell安装目录的完整路径。|
| 23 | $PSVersionTable | 此变量用于表示只读哈希表，该哈希表显示有关当前会话中运行的PowerShell版本的详细信息。 |
| 24 |$PWD| 此变量用于包含路径对象，该路径对象显示当前目录的完整路径。 |
| 25 |$ShellId| 此变量用于表示当前Shell的标识符。 |

```

``` 
1.$$
此变量用于表示会话接收到的最后一行中的最后一个令牌。
2.$?
此变量用于表示最后一个操作的执行状态。如果没有错误，则返回True，否则返回False。
3.$^
此变量用于表示会话接收到的最后一行中的第一个令牌。
4.$_
此变量充当$PSItem，它在管道对象中包含当前对象。
5.$args
此变量包含未声明参数的值的数组，这些值传递给脚本，函数或脚本块。
6.$ConsoleFileName
此变量用于表示控制台文件的路径，该文件最近在会话中使用。
7.$Error
此变量用于包含代表最新错误的错误对象数组。
8.$Event
此变量用于包含PSEventArgs的对象。PSEventArgs是用于表示正在处理的事件的对象。
9.$EventSubscriber
此变量用于包含PSEventSubscriber的对象。该对象包含正在处理的事件的事件订阅者。
10.$EventArgs
此变量用于包含一个对象，该对象表示第一个事件的参数。
11.$false
此变量用于表示False。
12.$foreach
此变量用于包含ForEach循环的枚举数。该变量仅在执行ForEach循环时存在。并在循环完成后删除。
13.$Home
此变量用于表示用户主目录的完整路径
14.$input
此变量包含一个枚举器，该枚举器枚举传递给该函数的所有输入。它仅适用于脚本块和功能。
15.$Host
此变量包含一个对象，该对象显示Windows PowerShell的当前主机应用程序。
16.$IsLinux
如果当前会话在Linux操作系统上运行，则此变量值为$True，否则为$False。
17.$IsWindows
如果当前会话在Windows操作系统上运行，则此变量值为$True，否则为$False。
18.$IsMacOS
如果当前会话在MacOS操作系统上运行，则此变量值为$True，否则为$False。
19.$null
此变量用于表示null值或空值。可以使用它来表示脚本和命令中缺少或未定义的值。
20.$PID
此变量显示进程的PID，该进程正在托管当前PowerShell的会话。
21.$PSItem
此变量充当$_，它在管道对象中包含当前对象。
22.$PSHome
此变量表示Windows PowerShell安装目录的完整路径。
23.$PSVersionTable
此变量用于表示只读哈希表，该哈希表显示有关当前会话中运行的PowerShell版本的详细信息。
24.$PWD
此变量用于包含路径对象，该路径对象显示当前目录的完整路径。
25.$ShellId
此变量用于表示当前Shell的标识符。

```



## 2.对象的集合
### 2.1 数组
#### 1.创建和初始化数组
要在powershell中声明数组，可以使用赋值运算符将多个值分配给变量。逗号分隔存储在数组中的值。
以下语句是声明数组变量的语法：
```
variable_name = value1,value2,value3,...,valueN
```
示例：要创建和初始化$k数组，该数组包含5个整数值：10,15,20,50,99.在powershell中键入以下命令：
```
$k = 10,15,20,50,99
```
还可以使用范围运算符来初始化数组
示例：要创建和初始化数组$arr,该数组包含从2到10的值
```
$arr = 2..10
```

#### 2.访问数组袁术
eg1：假设数组$array1包含：11,20,30,50,66,99显示数组所有值：
```
$array1 = 11,20,30,50,66,99
$array1
```
还可以使用索引号从数组访问元素，将索引号括在方括号中
``` 
$variable_name [index_number]
```
访问3-6元素
```
$array[2..5]
```
使用负数访问数组的最后一部分,最后一个元素访问
```
$array[-1]
```

要以索引号升序显示数组最后四个元素
```
$array[-4..-1]
```
#### 3.数组大小
获取数组长度
```
$varible_name.Length
```
eg:如果创建一个新数组$a,其中包含5个元素, 数组长度为
```
$a.Length
```

#### 4.数组的操作
更改数组的值
```
$p[2]=20
```
使用+=将值添加到数组
``` 
$variable_name += value
```
``` 
$a+=15
```

#### 5.初始化一个空数组
```
$variable_name = @()
```

#### 6.从数组中删除元素
删除第一个和最后一个
```
$array = 20,25,35,50,68
$array = ($array[1] $array[2] $array[3])
```

### 2.2 字典
#### 1.语法
创建hash语法
```
$variable_name = @{ <key1> = <value>; <key2> = <value2>;.....;<KeyN> = <valueN>;}
```
创建有序字典
```
$variable_name = {order}@{<key1> = <value1>;<key2> = <value2>;.....;<KeyN> = <valueN>;}
```

#### 2.创建哈希表
步骤：
1.创建一个以@符号开头的哈希表
2.将hash表括在花括号中
3.输入一个或多个键值对作为哈希表的数据（内容）。
4.要分隔每个值的键，必须使用等号(=)
5.包含空格的键将它们括在引号中。并且这些值必须是powershell的有效表达式。
6.要管理或使用哈希表，请将哈希表分配给变量
7.将有序的哈希表分配给变量时，可以将有序的属性放在@符号之前

创建空的哈希表：
```
$variablename = @{}
```

创建哈希表时，我们还可以将其添加到hash表中，

```
$student = @{name="Maxsu";Course="数学";Age = 25}
```

### 3.显示hash表
显示哈希表，默认情况会显示带有两列的表，一列用于键，另一列用于键值
```
$Student
```

显示哈希表的所有键或者所有值，请用点(.)表示
```
$Student.keys
$Student.values
```

哈希表具有count属性
```
$Student.count
```

下面是一个完整的示例，演示了如何创建，初始化和处理哈希表
```
$hash = @{ID = 1;Shape = "Square";Color = "Blue"}

write-host("Print all hashable keys")
$hash.keys

write-host("Get ID")
$hash["ID"]

write-host("Get Shape")
$hash.Number

write-host("print Size")
$hash.Count

write-host("Add key-value")
$hash["Updated"]="Now"

write-host("Add key-value")
$hash.Add("Create","Now")

write-host("print Size")
$hash.Count

write-host("Remove key-value")
$hash.Remove("Updated")


write-host("print Size")
$hash.Count

write-host("sort by key")
$hash.GetEnumerator() | Sort-Object -Property key
```

注释为 #


### 4.运算符
https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_operators?view=powershell-7.3
#### 4.1比较运算符
以下是相等比较运算符的列表
-eq(等于)
-ne(不等于)
-gt(大于)
-ge(大于或等于)
-lt(小于)
-le(小于或等于)
#### 4.2 匹配运算符
-like
-notlike
like后面可以添加通配符
-match
-notmatch
match可以添加正则
#### 4.3 包含运算符
-contain
-notcontain
-in
-notin
contains表示右边是否左边有 in表示左边是否右边有

### 5.控制流程
#### 5.1 选择
```
if (test_expression 1)
{
	Statement-1
	Statement-2.......
	Statement-N
}
else if(test_expression 2){
	Statement-1
	Statement-2.......
	Statement-N
}
else if(test_expression N){
	Statement-1
	Statement-2.......
	Statement-N
}
else
{
	Statement-1
	Statement-2.......
	Statement-N
}
```

```
$day = 3
swwitch($day)
{
	1(echo "今天是星期一")
	2(echo "今天是星期二")
	3(echo "今天是星期三")
	4(echo "今天是星期四")
	5(echo "今天是星期五")
	6(echo "今天是星期六")
	7(echo "今天是星期七")
	default(echo "请输入1-7")
}
```

#### 5.2 循环
##### 5.2.1 计次循环
```
for($x=1;$x -lt 10;$x=$x+1)
{
	echo $x
}
```

```
foreach($file in get-childitem)
{
	echo $file
}
```

##### 5.2.2 条件循环
```
while($count -le 5)
{
	echo $count
	$count +=1
}
```

```
$i=1
do{
	echo $i
	$i=$i+1
}while($i -le 10)
```

##### continue
```
$a = 1
while($a - le 10)
{
	if($a -eq 5)
	{
		$a+=1
		continue
		}
echo $a
$a +=1
}
```

##### break
```
for($a=1;$a -lt 10;$a++)
{
	if($a -eq 6)
	{
		break
	}
echo $a
}
```

### 6.函数
```
function mignzi([int]$x)
{
	$res = $x*$x
	return res
}
```

```
$x = mignzi(2)
```

### 7.win32api
```
Add-Type -TypeDefinition @"
using System;
using System.Diagnostics;
uisng System.Runtime.InteropServices;
[StructLayout(LayoutKind.Sequential)]
public struct PROCESS_INFORMATION
{
	public IntPtr hProcess;
	public IntPtr hThread;
	public uint dwProcessId;
	public uint dwThreadId;
}
[StructLayout(LayoutKind.Sequential,CharSet.Unicode)]
public struct STARTUPINFO
{
	public uint cb;
	public string lpReserved;
	public string lpTitle;
}

```

### 8.下载文件
```
invoke-webrequest -Url $url -OutFile $output
```

```
(New-Object System.Net.webClient).DownloadFile($url,$output)
```

```
Start-BitsTransfer -Source $url -Destination $output
```

### 9.混淆
#### 实例
